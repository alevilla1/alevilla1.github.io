{"version":3,"file":"ColorShape2-Bqv57vke.js","sources":["../../src/components/ColorShape/ColorShape2.tsx"],"sourcesContent":["import { useEffect, useRef } from \"react\";\nimport * as THREE from \"three\";\n\nexport default function ColorShape2() {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const sceneRef = useRef<THREE.Scene | null>(null);\n  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);\n  const meshRef = useRef<THREE.Mesh | null>(null);\n  const glowMeshRef = useRef<THREE.Mesh | null>(null);\n  const animationFrameRef = useRef<number | null>(null);\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n\n    const container = containerRef.current;\n    const width = container.clientWidth || 500;\n    const height = container.clientHeight || 500;\n\n    // Scene\n    const scene = new THREE.Scene();\n    scene.background = null;  // Explicitly null for transparency\n    sceneRef.current = scene;\n\n    // Camera\n    const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 100);\n    camera.position.z = 20;\n    cameraRef.current = camera;\n\n    // Renderer\n    const renderer = new THREE.WebGLRenderer({\n      antialias: true,\n      alpha: true,\n      premultipliedAlpha: false\n    });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n    renderer.setClearColor(0x000000, 0);  // Transparent background\n    renderer.autoClear = true;\n    container.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // --- CORE SHAPE (Torus Knot) ---\n    const geometry = new THREE.TorusKnotGeometry(1, 0.4, 128, 64);\n\n    // Shader material with fire-like animated effect\n    const material = new THREE.ShaderMaterial({\n      uniforms: {\n        uTime: { value: 0 },\n        uColor1: { value: new THREE.Color(0.04, 0.81, 0.44) },\n        uColor2: { value: new THREE.Color(0.61, 0.25, 0.72) },\n        uColor3: { value: new THREE.Color(0.31, 0.61, 0.39) },\n        uColor4: { value: new THREE.Color(0.79, 0.49, 0.15) },\n        uColor5: { value: new THREE.Color(0.72, 1.0, 0.48) },\n        uColor6: { value: new THREE.Color(0.75, 0.41, 0.22) },\n      },\n      vertexShader: `\n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n\n        void main() {\n          vUv = uv;\n          vNormal = normalize(normalMatrix * normal);\n          vPosition = position;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n      `,\n      fragmentShader: `\n        uniform float uTime;\n        uniform vec3 uColor1;\n        uniform vec3 uColor2;\n        uniform vec3 uColor3;\n        uniform vec3 uColor4;\n        uniform vec3 uColor5;\n        uniform vec3 uColor6;\n        \n        varying vec2 vUv;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n\n        // Noise functions\n        float rand(vec2 n) {\n          return fract(cos(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n        }\n        \n        float noise(vec2 n) {\n          const vec2 d = vec2(0.0, 1.0);\n          vec2 b = floor(n);\n          vec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n          return mix(\n            mix(rand(b), rand(b + d.yx), f.x),\n            mix(rand(b + d.xy), rand(b + d.yy), f.x),\n            f.y\n          );\n        }\n        \n        float fbm(vec2 n) {\n          float total = 0.0;\n          float amplitude = 1.0;\n          for (int i = 0; i < 4; i++) {\n            total += noise(n) * amplitude;\n            n += n;\n            amplitude *= 0.5;\n          }\n          return total;\n        }\n\n        void main() {\n          vec2 p = vUv * 8.0;\n          float q = fbm(p - uTime * 0.1);\n          vec2 r = vec2(\n            fbm(p + q + uTime * 0.3 - p.x - p.y),\n            fbm(p + q - uTime * 0.2)\n          );\n          \n          // Color mixing - reduced subtraction to prevent dark spots\n          vec3 c = mix(uColor1, uColor2, fbm(p + r)) +\n                   mix(uColor3, uColor4, r.x) -\n                   mix(uColor5, uColor6, r.y) * 0.5; // Reduced dark mixing\n          \n          // Prevent fading to black at edges\n          vec3 color = c * (0.3 + 0.7 * cos(1.5 * vUv.y)); // Lifted shadows\n\n          // HDR / Vibrancy effect\n          // Increase contrast\n          color = pow(color, vec3(1.2));\n          \n          // Boost saturation/vibrancy\n          vec3 gray = vec3(dot(color, vec3(0.299, 0.587, 0.114)));\n          color = mix(gray, color, 1.4); // 1.4 saturation boost\n\n          // Standard fresnel for subtle rim\n          float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 3.0);\n          color += fresnel * vec3(0.5, 0.4, 0.8); // Slightly brighter rim\n\n          // High brightness for HDR look\n          color *= 1.8;\n\n          gl_FragColor = vec4(color, 1.0); // Opaque core\n        }\n      `,\n      transparent: false, // Opaque core as requested to show colors better\n      side: THREE.DoubleSide,\n    });\n\n    const mesh = new THREE.Mesh(geometry, material);\n    mesh.scale.set(3, 3, 3);\n    scene.add(mesh);\n    meshRef.current = mesh;\n\n\n    // --- VOLUMETRIC RAYS (Displaced Mesh) ---\n    // This mesh is a clone of the original but with vertices pushed out by noise\n    // to create actual 3D light spikes that rotate WITH the object.\n    const raysMaterial = new THREE.ShaderMaterial({\n      uniforms: {\n        uTime: { value: 0 },\n        uColor1: { value: new THREE.Color(0.04, 0.81, 0.44) },\n        uColor2: { value: new THREE.Color(0.1, 0.1, 0.8) },\n        uColor3: { value: new THREE.Color(0.31, 0.61, 0.39) },\n        uColor4: { value: new THREE.Color(0.79, 0.49, 0.15) },\n        uColor5: { value: new THREE.Color(0.0, 0.8, 0.8) },\n        uColor6: { value: new THREE.Color(0.2, 0.4, 1.0) },\n      },\n      vertexShader: `\n        uniform float uTime;\n        varying vec3 vNormal;\n        varying vec3 vPosition;\n        varying vec3 vWorldPosition;\n        varying float vNoise;\n\n        // Simplex noise for vertex displacement\n        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }\n        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n        float snoise(vec3 v) {\n          const vec2  C = vec2(1.0/6.0, 1.0/3.0);\n          const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n          vec3 i  = floor(v + dot(v, C.yyy));\n          vec3 x0 = v - i + dot(i, C.xxx);\n          vec3 g = step(x0.yzx, x0.xyz);\n          vec3 l = 1.0 - g;\n          vec3 i1 = min(g.xyz, l.zxy);\n          vec3 i2 = max(g.xyz, l.zxy);\n          vec3 x1 = x0 - i1 + C.xxx;\n          vec3 x2 = x0 - i2 + C.yyy;\n          vec3 x3 = x0 - D.yyy;\n          i = mod289(i);\n          vec4 p = permute(permute(permute(\n                     i.z + vec4(0.0, i1.z, i2.z, 1.0))\n                   + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n                   + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n          float n_ = 0.142857142857;\n          vec3  ns = n_ * D.wyz - D.xzx;\n          vec4 j = p - 49.0 * floor(p * ns.z * ns.z);\n          vec4 x_ = floor(j * ns.z);\n          vec4 y_ = floor(j - 7.0 * x_);\n          vec4 x = x_ *ns.x + ns.yyyy;\n          vec4 y = y_ *ns.x + ns.yyyy;\n          vec4 h = 1.0 - abs(x) - abs(y);\n          vec4 b0 = vec4(x.xy, y.xy);\n          vec4 b1 = vec4(x.zw, y.zw);\n          vec4 s0 = floor(b0)*2.0 + 1.0;\n          vec4 s1 = floor(b1)*2.0 + 1.0;\n          vec4 sh = -step(h, vec4(0.0));\n          vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n          vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n          vec3 p0 = vec3(a0.xy,h.x);\n          vec3 p1 = vec3(a0.zw,h.y);\n          vec3 p2 = vec3(a1.xy,h.z);\n          vec3 p3 = vec3(a1.zw,h.w);\n          vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));\n          p0 *= norm.x;\n          p1 *= norm.y;\n          p2 *= norm.z;\n          p3 *= norm.w;\n          vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n          m = m * m;\n          return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));\n        }\n\n        void main() {\n          vNormal = normalize(normalMatrix * normal);\n          \n          // Generate noise based on position and time\n          float noiseVal = snoise(position * 2.0 + uTime * 0.5);\n          float spikes = max(0.0, snoise(position * 8.0 + uTime * 1.0));\n          \n          // Combine noise\n          float displacement = (noiseVal * 0.5 + spikes * 1.5) * 0.5;\n          \n          // Only displace outwards\n          displacement = max(0.0, displacement);\n          vNoise = displacement;\n          \n          // Move vertex along normal\n          vec3 newPos = position + normal * displacement;\n          \n          vPosition = newPos;\n          \n          // Calculate world position here in vertex shader (modelMatrix available here)\n          vWorldPosition = (modelMatrix * vec4(newPos, 1.0)).xyz;\n          \n          gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);\n        }\n      `,\n      fragmentShader: `\n        uniform float uTime;\n        uniform vec3 uColor1;\n        uniform vec3 uColor2;\n        uniform vec3 uColor3;\n        uniform vec3 uColor4;\n        uniform vec3 uColor5;\n        uniform vec3 uColor6;\n        \n        varying vec3 vNormal;\n        varying vec3 vPosition;\n        varying vec3 vWorldPosition;\n        varying float vNoise;\n\n        void main() {\n          float n = vNoise;\n          \n          vec3 c = mix(uColor1, uColor2, n) +\n                   mix(uColor3, uColor4, n * 0.5) +\n                   mix(uColor5, uColor6, 1.0 - n);\n          \n          // Fresnel for soft edges - now using vWorldPosition from vertex shader\n          vec3 viewDir = normalize(cameraPosition - vWorldPosition);\n          float fresnel = pow(1.0 - abs(dot(vNormal, viewDir)), 2.0);\n          \n          vec3 color = c * 2.0;\n          \n          gl_FragColor = vec4(color, 0.4 * fresnel);\n        }\n      `,\n      transparent: true,\n      blending: THREE.AdditiveBlending,\n      side: THREE.DoubleSide,\n      depthWrite: false,\n    });\n\n    const raysMesh = new THREE.Mesh(geometry, raysMaterial);\n    raysMesh.scale.set(3, 3, 3);\n    scene.add(raysMesh);\n    glowMeshRef.current = raysMesh;\n\n\n    // Lighting\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n    scene.add(ambientLight);\n    const pointLight = new THREE.PointLight(0xffffff, 1);\n    pointLight.position.set(5, 5, 5);\n    scene.add(pointLight);\n\n    // Animation\n    const clock = new THREE.Clock();\n    const animate = () => {\n      if (!containerRef.current || !rendererRef.current || !sceneRef.current || !cameraRef.current) {\n        return;\n      }\n\n      animationFrameRef.current = requestAnimationFrame(animate);\n\n      const elapsedTime = clock.getElapsedTime();\n\n      // Update uniforms\n      if (material.uniforms.uTime) material.uniforms.uTime.value = elapsedTime;\n      if (raysMaterial.uniforms.uTime) raysMaterial.uniforms.uTime.value = elapsedTime;\n\n      // Rotate mesh\n      if (meshRef.current) {\n        meshRef.current.rotation.y -= 0.003;\n        meshRef.current.rotation.x += 0.001;\n      }\n\n      // Rotate rays (sync with mesh EXACTLY)\n      if (glowMeshRef.current) {\n        glowMeshRef.current.rotation.y -= 0.003;\n        glowMeshRef.current.rotation.x += 0.001;\n      }\n\n      rendererRef.current.render(sceneRef.current, cameraRef.current);\n    };\n\n    animate();\n\n    // Handle resize\n    const handleResize = () => {\n      if (!containerRef.current || !rendererRef.current || !cameraRef.current) return;\n\n      const width = containerRef.current.clientWidth || 500;\n      const height = containerRef.current.clientHeight || 500;\n\n      cameraRef.current.aspect = width / height;\n      cameraRef.current.updateProjectionMatrix();\n      rendererRef.current.setSize(width, height);\n    };\n\n    window.addEventListener(\"resize\", handleResize);\n\n    // Cleanup\n    return () => {\n      if (animationFrameRef.current) {\n        cancelAnimationFrame(animationFrameRef.current);\n        animationFrameRef.current = null;\n      }\n\n      window.removeEventListener(\"resize\", handleResize);\n\n      if (geometry) geometry.dispose();\n      if (material) material.dispose();\n      if (raysMaterial) raysMaterial.dispose();\n\n      if (rendererRef.current) {\n        rendererRef.current.dispose();\n        if (container && container.contains(rendererRef.current.domElement)) {\n          container.removeChild(rendererRef.current.domElement);\n        }\n        rendererRef.current = null;\n      }\n\n      sceneRef.current = null;\n      cameraRef.current = null;\n      meshRef.current = null;\n      glowMeshRef.current = null;\n    };\n  }, []);\n\n  return <div ref={containerRef} className=\"homepage-color-shape\" />;\n}\n\n\n"],"names":["ColorShape2","containerRef","useRef","rendererRef","sceneRef","cameraRef","meshRef","glowMeshRef","animationFrameRef","useEffect","container","width","height","scene","THREE.Scene","camera","THREE.PerspectiveCamera","renderer","THREE.WebGLRenderer","geometry","THREE.TorusKnotGeometry","material","THREE.ShaderMaterial","THREE.Color","THREE.DoubleSide","mesh","THREE.Mesh","raysMaterial","THREE.AdditiveBlending","raysMesh","ambientLight","THREE.AmbientLight","pointLight","THREE.PointLight","clock","THREE.Clock","animate","elapsedTime","handleResize","jsx"],"mappings":"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"}